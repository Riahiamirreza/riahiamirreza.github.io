## Modifying local variables of a function from outer scopes

I was wondering if it is possible to modify a variable's value of a function, before the function is actually invoked in `C`. I completely understand that this looks very insane, and irrational, but while in `C` we are allowed to do whatever we want with memory, thus we can change the value of the memory address of that variable. But since the function isn't yet invoked, how can we figure out the memory address?

Let's say this is our program:
```c
#include <stdio.h>

void foo() {
        int x;
        printf("%d\n", x);
}

int main(int argc, char *argv[]) {
        foo();
        return 0;
}
```
Of course using value of an uninitialized variable is undefined-behavior, but let us go ahead and enjoy playing with raw memory bytes.  By looking at the assembly generated by `gcc` for this peice of code we can better understand how it works. I use `objdump -S` to convert an executable into a human-readable assembly code.
```bash
{amirreza@localhost modification}
 > gcc useless.c
{amirreza@localhost modification}
 > objdump -S a.out ...
```
This is assembly generated for `foo`:
```
0000000000401126 <foo>:
  401126:	55                   	push   %rbp
  401127:	48 89 e5             	mov    %rsp,%rbp
  40112a:	48 83 ec 10          	sub    $0x10,%rsp
  40112e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401131:	89 c6                	mov    %eax,%esi
  401133:	bf 10 20 40 00       	mov    $0x402010,%edi
  401138:	b8 00 00 00 00       	mov    $0x0,%eax
  40113d:	e8 ee fe ff ff       	callq  401030 <printf@plt>
  401142:	90                   	nop
  401143:	c9                   	leaveq 
  401144:	c3                   	retq   
```
At this point `sub    $0x10,%rsp` the compiler is allocating stack memory for local variable `x`. You may have noticed that it is allocating more than what is seemingly needed, `int x` in most architectures (including my computer) has size of 4 bytes, but by subtracting `rsp` 16 bytes, we are allocating more memory than just what is needed for `x`. You can look at [this question](https://stackoverflow.com/questions/34170306/gcc-reserving-more-space-than-needed-for-local-variables) for the understanding why it is the case. But for now, we can assume that first 4 bytes of the allocated space is for `x` (You can figure out using `gdb`). So if we write at that address, that will hopefully be the value of `x`.
```c
#include <stdio.h>
#include <stdlib.h>

void foo() {
        int x;
        printf("%d\n", x);
}

int main(int argc, char *argv[]) {
        *(&argc-8) = atoi(argv[1]);
        foo();
        return 0;
}
```
In this version of code, I try to access the memory of `x` using `argc` memory address. And using `gdb` I figured out in my compiled version of code, (remember this is very dependant on your compiler, optimization level, OS, et cetra) `x` resides 32 bytes below the `argc`. Note that `&argc-8` is actually subtracting 8 times of size of pointer (which is 32 bytes) from `&argc`. And the result is as below:
```bash
{amirreza@localhost modification}
 > ./a.out 2
2
{amirreza@localhost modification}
 > ./a.out 24
24
```
Note that we are abusing an undefined-behavior. This code is not guaranteed to work. The compiler can choose to clear all stack allocated memory addresses once they are allocated. 

```bash

 > gcc --version
gcc (GCC) 10.3.1 20210422 (Red Hat 10.3.1-1)
Copyright (C) 2020 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

```
