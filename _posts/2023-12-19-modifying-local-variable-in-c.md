## Modifying local variables of a function from outer scopes

I was wondering if it is possible to modify a variable's value of a function, before the function is actually invoked in `C`. I completely understand that this looks very insane and irrational, but while in `C` we are allowed to do whatever we want with memory, thus we can change the value of the memory address of that variable. But since the function isn't yet invoked, how can we figure out the memory address?

Let's say this is our program:
```c
#include <stdio.h>

void foo() {
        int x;
        printf("%d\n", x);
}

int main(int argc, char *argv[]) {
        foo();
        return 0;
}
```
Of course using value of an uninitialized variable is undefined-behavior, but let us go ahead and enjoy playing with raw memory.  By looking at the assembly generated by `gcc` for this peice of code we can better understand how it works. I use `objdump -S` to convert an executable into a human-readable assembly code.
```bash
{amirreza@localhost modification}
 > gcc useless.c
{amirreza@localhost modification}
 > objdump -S a.out
```
This is assembly generated for `foo`:
```
0000000000401126 <foo>:
  401126:	55                   	push   %rbp
  401127:	48 89 e5             	mov    %rsp,%rbp
  40112a:	48 83 ec 10          	sub    $0x10,%rsp
  40112e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401131:	89 c6                	mov    %eax,%esi
  401133:	bf 10 20 40 00       	mov    $0x402010,%edi
  401138:	b8 00 00 00 00       	mov    $0x0,%eax
  40113d:	e8 ee fe ff ff       	callq  401030 <printf@plt>
  401142:	90                   	nop
  401143:	c9                   	leaveq 
  401144:	c3                   	retq   
```
At this point `sub    $0x10,%rsp` the compiler is allocating stack memory for local variable `x`. You may have noticed that it is allocating more than what is seemingly needed, `int x` in most architectures (including my computer) has size of 4 bytes, but by subtracting `rsp` 16 bytes, we are allocating more memory than just what is needed for `x`. You can look at [this question](https://stackoverflow.com/questions/34170306/gcc-reserving-more-space-than-needed-for-local-variables) to understand why it is the case. But for now, we can assume `x` will be placed somewhere in that allocated chunk (We will figure out the exact address using `gdb`). So if we write at that address, that will hopefully change the value of `x`.
I investigated address of stack variables using `gdb` to find where will `x` reside. More accurately I tried to find the relative distance of two variables, `argc` and `x`.
```bash
{amirreza@localhost modification}
 > gcc useless.c -ggdb
```
I compiled the program using `-ggdb` flag. The `gcc` clearly explains why should we use that when we're using `gdb` debugger:
```
       -ggdb
           Produce debugging information for use by GDB.  This means to use the most expressive format available (DWARF, stabs, or the native format if neither of those
           are supported), including GDB extensions if at all possible.
```
And then running gdb:
```bash
{amirreza@localhost modification}
 > gdb a.out 
GNU gdb (GDB) Fedora 9.1-3.fc32
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...
(gdb) break main
Breakpoint 1 at 0x401154: file useless.c, line 10.
(gdb) run
Starting program: /tmp/another/modification/a.out 
Missing separate debuginfos, use: dnf debuginfo-install glibc-2.31-2.fc32.x86_64

Breakpoint 1, main (argc=1, argv=0x7fffffffdfe8) at useless.c:10
10	        foo();
(gdb)
```
I set a breakpoint on the `main` function and run the code, and as you see the execution is paused on the `main`.
```C
(gdb) p &argc
$1 = (int *) 0x7fffffffdeec
(gdb) s
foo () at useless.c:6
6	        printf("%d\n", x);
(gdb) p &x
$2 = (int *) 0x7fffffffdecc
(gdb) 
```
As you can see, the address of `argc` is `0x7fffffffdeec` and address of `x` is `0x7fffffffdecc`. The difference is 32 (8 integers). So `x` reside 32 bytes below of `argc`. Therefore if I try to write some value 32 bytes belower than where `argc` resides, I can hope that this will be the value of `x` when `foo` is invoked.
```c
#include <stdio.h>
#include <stdlib.h>

void foo() {
        int x;
        printf("%d\n", x);
}

int main(int argc, char *argv[]) {
        *(&argc-8) = atoi(argv[1]);
        foo();
        return 0;
}
```
Here `&argc-8` is actually subtracting 8 times of size of integer (which is 4 bytes) from `&argc`. Remember that the distance between `argc`'s address and `x`'s address is very dependant on your compiler, optimization level, OS, et cetra and can easily change. The result is as below:
```bash
{amirreza@localhost modification}
 > ./a.out 2
2
{amirreza@localhost modification}
 > ./a.out 24
24
```

Note that we are abusing an undefined-behavior. This code is not guaranteed to work. The compiler can choose to clear all stack allocated memory addresses once they are allocated or it can choose to put `x` somewhere else instead of 32 bytes belower than `argc`. In other words, this code is completely relied on the implementation details of the compiler, not specification of the language. 
When I try to compile it with `-O3` the result is not as I expected before:
```Bash
{amirreza@localhost modification}
 > gcc useless.c -O3
{amirreza@localhost modification}
 > ./a.out 12
0
{amirreza@localhost modification}
 > ./a.out 15
0
```
It's due to the fact that the compiler is free on how to manage the memory, and may choose to put `x` somewhere else. Futhermore this behaiour can (and in my case will) change by changing the compiler. This is the result of code when I use `clang` instead of `gcc`:

```bash
{amirreza@localhost modification}
 > clang useless.c 
{amirreza@localhost modification}
 > ./a.out 1
32610
{amirreza@localhost modification}
 > ./a.out 14
32731

```
As you can see, by no means we can rely on this type of abusing memory.

My `gcc` version:
```bash

 > gcc --version
gcc (GCC) 10.3.1 20210422 (Red Hat 10.3.1-1)
Copyright (C) 2020 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

```
